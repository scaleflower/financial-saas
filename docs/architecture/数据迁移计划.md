# 数据迁移计划

## 📊 数据库信息

### 源数据库（旧系统）

| 项目 | 值 |
|------|-----|
| 数据库类型 | MySQL |
| 数据库名 | fs_enabling |
| 主机 | localhost |
| 端口 | 3306 |
| 用户名 | root |
| 密码 | iWhale@2023 |
| 系统 | Mac OS |

### 目标数据库（新系统）

| 项目 | 值 |
|------|-----|
| 数据库类型 | PostgreSQL 15+ |
| 数据库名 | new_fs |
| 主机 | localhost |
| 端口 | 5432 |
| 用户名 | heyake |
| 密码 | (空) |
| 系统 | Mac OS |

---

## 📈 数据量估算

### 历史数据统计

| 表名 | 预估记录数 | 说明 |
|------|----------|------|
| trans | 862 | 报销单（Company B) |
| trans_item | ~2500 | 报销明细 |
| charge_item | ~5000 | 费用明细 |
| loan | 13 | 借款记录（Company B) |
| repayment | 7 | 还款记录（Company B) |
| user | ~50 | 用户数据（Company B) |
| org | ~10 | 组织数据（Company B) |
| role | ~15 | 角色数据（Company B) |
| trans_attach | ~200 | 报销附件 |
| loan_attach | ~30 | 借款附件 |
| repayment_attach | ~20 | 还款附件 |

**总计估算**: ~8500 条记录 + ~250 个附件文件

---

## 🔄 迁移策略

### 方案选择：**渐进式迁移 + 数据双写**

#### 阶段1: 并行运行（1-2周）
- [ ] 旧系统继续运行
- [ ] 新系统部署到测试环境
- [ ] 数据迁移脚本开发
- [ ] 小规模数据测试迁移

#### 阶段2: 验证测试（1周）
- [ ] 完整数据迁移测试
- [ ] 业务逻辑验证
- [ ] 性能测试
- [ ] 用户验收测试

#### 阶段3: 数据割接（1天）
- [ ] 停止旧系统写入
- [ ] 执行最终数据迁移
- [ ] 切换到新系统
- [ ] 监控运行状态

#### 阶段4: 旧系统下线（1周）
- [ ] 旧系统归档
- [ ] 数据备份
- [ ] 文档归档

---

## 📋 迁移任务清单

### 1. 数据分析（任务ID: MIG-001）

**目标**: 分析源数据库结构，生成数据字典

**子任务**:
- [ ] 导出 fs_enabling 数据库结构
- [ ] 生成数据字典文档
- [ ] 分析表关系和外键
- [ ] 识别特殊数据类型
- [ ] 识别存储过程和触发器
- [ ] 识别工作流相关表

**交付物**:
- [x] `01-data-dictionary.md` - 数据字典
- [ ] `02-schema-analysis.md` - Schema 分析报告

---

### 2. 数据类型映射（任务ID: MIG-002）

**目标**: 建立 MySQL 到 PostgreSQL 的类型映射规则

**映射规则**:

| MySQL 类型 | PostgreSQL 类型 | 说明 |
|----------|---------------|------|
| bigint | BIGINT | 大整数 |
| int | INTEGER | 整数 |
| varchar(n) | VARCHAR(n) | 变长字符串 |
| text | TEXT | 长文本 |
| datetime | TIMESTAMP | 日期时间 |
| date | DATE | 日期 |
| decimal(12,2) | NUMERIC(12,2) | 小数 |
| tinyint | SMALLINT | 小整数 |
| enum | VARCHAR + CHECK | 枚举转字符串 + 约束 |
| json | JSONB | JSON 数据 |

**注意事项**:
- MySQL 的 AUTO_INCREMENT → PostgreSQL 的 SERIAL 或 GENERATED
- MySQL 的 TINYINT(1) → PostgreSQL 的 SMALLINT
- MySQL 的 TEXT/LONGTEXT → PostgreSQL 的 TEXT

**交付物**:
- [x] `03-type-mapping.md` - 类型映射规则

---

### 3. 数据清洗脚本（任务ID: MIG-003）

**目标**: 清洗源数据，修复数据不一致

**清洗规则**:

1. **空值处理**:
   - NULL 值保留
   - 空字符串转为 NULL（根据业务规则）
   
2. **重复数据**:
   - 识别重复记录
   - 保留最新或有效的记录
   - 标记删除重复记录

3. **数据一致性**:
   - 外键关系验证
   - 引用完整性检查
   - 孤儿数据清理

4. **数据格式标准化**:
   - 日期格式统一
   - 金额格式统一（保留2位小数）
   - 字符编码统一（UTF-8）

**交付物**:
- [x] `04-data-cleaning.sql` - 数据清洗 SQL
- [x] `05-data-validation.sql` - 数据验证 SQL

---

### 4. 用户数据迁移（任务ID: MIG-004）

**目标**: 迁移用户数据，处理密码加密

**迁移逻辑**:

```sql
-- 1. 创建新系统用户表
CREATE TABLE "user" (
    tenant_id BIGINT NOT NULL,
    user_id BIGSERIAL,
    username VARCHAR(100) NOT NULL,
    password VARCHAR(100) NOT NULL,
    realname VARCHAR(60) NOT NULL,
    email VARCHAR(100) NOT NULL,
    state INTEGER DEFAULT 0,
    org_id BIGINT,
    PRIMARY KEY (tenant_id, user_id)
);

-- 2. 迁移用户数据（Company B: tenant_id = 2）
INSERT INTO "user" (tenant_id, user_id, username, password, realname, email, state, org_id)
SELECT 
    2 as tenant_id,
    user_id,
    username,
    -- ⚠️ 密码需要重新加密或要求用户重置
    '' as password,  -- 先设置为空，要求用户首次登录重置
    realname,
    email,
    state,
    org_id
FROM fs_enabling.user;

-- 3. 生成密码重置链接或临时密码
-- 这个步骤需要在新系统的认证服务中实现
```

**密码处理方案**:

**方案A**: 批量重置密码
- 所有用户密码重置为临时密码
- 首次登录要求修改密码

**方案B**: 迁移哈希（不推荐）
- 尝试迁移 Shiro MD5 哈希到 BCrypt
- 风险：算法可能不兼容

**方案C**: 邮件通知（推荐）
- 迁移后发送密码重置邮件
- 用户通过邮件链接设置新密码

**交付物**:
- [x] `06-migrate-users.sql` - 用户数据迁移脚本
- [x] `07-password-reset.sql` - 密码重置脚本

---

### 5. 组织数据迁移（任务ID: MIG-005）

**目标**: 迁移组织架构数据

**迁移逻辑**:

```sql
-- 迁移组织数据（Company B）
INSERT INTO org (tenant_id, org_id, org, org_name, comments, state, parent_org_id)
SELECT 
    2 as tenant_id,
    org_id,
    org,
    org_name,
    comments,
    state,
    parent_org_id
FROM fs_enabling.org;
```

**注意事项**:
- 保持组织树结构
- 验证父子关系
- 处理循环引用

**交付物**:
- [x] `08-migrate-org.sql` - 组织数据迁移脚本

---

### 6. 权限数据迁移（任务ID: MIG-006）

**目标**: 迁移角色和权限数据

**迁移逻辑**:

```sql
-- 迁移角色数据
INSERT INTO role (tenant_id, role_id, role, role_name, comments, org_id)
SELECT 
    2 as tenant_id,
    role_id,
    role,
    role_name,
    comments,
    org_id
FROM fs_enabling.role;

-- 迁移用户角色关联
INSERT INTO user_role (tenant_id, user_role_id, user_id, role_id)
SELECT 
    2 as tenant_id,
    user_role_id,
    user_id,
    role_id
FROM fs_enabling.user_role;

-- 迁移权限数据
INSERT INTO perm (tenant_id, perm_id, perm, perm_name, comments)
SELECT 
    2 as tenant_id,
    perm_id,
    perm,
    perm_name,
    comments
FROM fs_enabling.perm;
```

**注意事项**:
- 保持 RBAC 模型
- 验证用户-角色-权限关系

**交付物**:
- [x] `09-migrate-permission.sql` - 权限数据迁移脚本

---

### 7. 报销数据迁移（任务ID: MIG-007）

**目标**: 迁移报销单和明细数据

**迁移逻辑**:

```sql
-- 1. 迁移报销单（主表）
INSERT INTO trans (
    tenant_id, trans_id, trans_code, created_date, state, state_date,
    trans_type_id, trans_type_name, trans_type_code,
    project_id, project_name, project_code, link_tel,
    pages, sheets, trans_desc, trans_charge, trans_sett_charge,
    trans_sett_desc, processinstance_id,
    created_user_id, created_user_name, created_job_number,
    sett_user_id, sett_user_name, sett_job_number,
    currency_id, exchange_rate, lc_charge
)
SELECT 
    2 as tenant_id,
    trans_id,
    trans_code,
    created_date,
    state,
    state_date,
    trans_type_id,
    trans_type_name,
    trans_type_code,
    project_id,
    project_name,
    project_code,
    link_tel,
    pages,
    sheets,
    trans_desc,
    trans_charge,
    trans_sett_charge,
    trans_sett_desc,
    processinstance_id,
    created_user_id,
    created_user_name,
    created_job_number,
    sett_user_id,
    sett_user_name,
    sett_job_number,
    COALESCE(currency_id, 1) as currency_id,  -- 默认币种
    COALESCE(exchange_rate, 1.0) as exchange_rate,  -- 默认汇率
    COALESCE(trans_charge * COALESCE(exchange_rate, 1.0), trans_charge) as lc_charge  -- 计算本币金额
FROM fs_enabling.trans;

-- 2. 迁移报销明细
INSERT INTO trans_item (
    tenant_id, trans_item_id, trans_id,
    trans_type_id, trans_type_name, trans_type_code,
    project_id, project_name, project_code,
    created_date, state,
    trans_item_name, trans_item_desc
)
SELECT 
    2 as tenant_id,
    trans_item_id,
    trans_id,
    trans_type_id,
    trans_type_name,
    trans_type_code,
    project_id,
    project_name,
    project_code,
    created_date,
    state,
    trans_item_name,
    trans_item_desc
FROM fs_enabling.trans_item;

-- 3. 迁移费用明细
INSERT INTO charge_item (
    tenant_id, charge_id, trans_item_id,
    expense_item_type_id, expense_item_type_name,
    charge_amount, lc_charge, exchange_rate,
    charge_desc, charge_date
)
SELECT 
    2 as tenant_id,
    charge_id,
    trans_item_id,
    expense_item_type_id,
    expense_item_type_name,
    charge_amount,
    charge_amount * COALESCE(ti.exchange_rate, 1.0) as lc_charge,
    COALESCE(ti.exchange_rate, 1.0) as exchange_rate,
    charge_desc,
    charge_date
FROM fs_enabling.charge_item ci
JOIN fs_enabling.trans_item ti ON ci.trans_item_id = ti.trans_item_id;
```

**注意事项**:
- 保持数据层级关系
- 计算本币金额（如果原始数据没有）
- 处理空值和默认值

**交付物**:
- [x] `10-migrate-trans.sql` - 报销数据迁移脚本

---

### 8. 借款数据迁移（任务ID: MIG-008）

**目标**: 迁移借款数据

**迁移逻辑**:

```sql
INSERT INTO loan (
    tenant_id, loan_id, loan_code, user_id,
    expense_item_type_id, project_id, loan_date,
    state, state_date, processinstance_id,
    loan_amount, loan_lc_amount, amount_repaid,
    description, currency_id, exchange_rate,
    link_tel, loan_sett_charge, loan_sett_desc,
    sett_user_id
)
SELECT 
    2 as tenant_id,
    loan_id,
    loan_code,
    user_id,
    expense_item_type_id,
    project_id,
    loan_date,
    state,
    state_date,
    processinstance_id,
    loan_amount,
    loan_amount * COALESCE(exchange_rate, 1.0) as loan_lc_amount,
    COALESCE(amount_repaid, 0) as amount_repaid,
    description,
    currency_id,
    exchange_rate,
    link_tel,
    loan_sett_charge,
    loan_sett_desc,
    sett_user_id
FROM fs_enabling.loan;
```

**交付物**:
- [x] `11-migrate-loan.sql` - 借款数据迁移脚本

---

### 9. 还款数据迁移（任务ID: MIG-009）

**目标**: 迁移还款数据

**迁移逻辑**:

```sql
-- 1. 迁移还款主表
INSERT INTO repayment (
    tenant_id, repayment_id, repayment_code, user_id,
    project_id, repayment_date, state, state_date,
    processinstance_id, repayment_amount, lc_repayment_amount,
    description, link_tel, sett_user_id
)
SELECT 
    2 as tenant_id,
    repayment_id,
    repayment_code,
    user_id,
    project_id,
    repayment_date,
    state,
    state_date,
    processinstance_id,
    repayment_amount,
    repayment_amount * COALESCE(exchange_rate, 1.0) as lc_repayment_amount,
    description,
    link_tel,
    sett_user_id
FROM fs_enabling.repayment;

-- 2. 迁移还款冲销记录
INSERT INTO repayment_sett (
    tenant_id, sett_id, repayment_id, loan_id,
    sett_amount, sett_date, sett_desc
)
SELECT 
    2 as tenant_id,
    sett_id,
    repayment_id,
    loan_id,
    sett_amount,
    sett_date,
    sett_desc
FROM fs_enabling.repayment_sett;
```

**交付物**:
- [x] `12-migrate-repayment.sql` - 还款数据迁移脚本

---

### 10. 工作流数据迁移（任务ID: MIG-010）

**目标**: 迁移 Activiti 流程实例到 Flowable

**迁移策略**:

**方案A**: 保留流程定义，只迁移实例
- 保持流程不变
- 迁移流程实例和历史任务
- 适用：流程定义相同的场景

**方案B**: 重新设计流程，迁移业务数据
- 使用新的 JSON 流程定义
- 重新启动流程实例
- 适用：流程需要改造的场景

**推荐**: 方案B（因为本项目要重构工作流系统）

**迁移逻辑**:

```sql
-- 1. 保存旧流程定义和历史数据
-- 2. 在新系统中重新设计流程
-- 3. 业务数据迁移完成后，重新提交到新流程
-- 4. 记录旧流程ID到新流程ID的映射关系
```

**交付物**:
- [x] `13-migrate-workflow.sql` - 工作流数据迁移脚本

---

### 11. 附件文件迁移（任务ID: MIG-011）

**目标**: 迁移附件文件从文件系统到 MinIO

**迁移逻辑**:

```bash
#!/bin/bash
# migrate-attachments.sh

# 配置
OLD_ATTACHMENTS_DIR="/path/to/old/attachments"
MINIO_ENDPOINT="http://localhost:9000"
MINIO_ACCESS_KEY="minioadmin"
MINIO_SECRET_KEY="minioadmin"
BUCKET_NAME="fs-files"

# 使用 MinIO CLI
mc alias set local $MINIO_ENDPOINT $MINIO_ACCESS_KEY $MINIO_SECRET_KEY

# 创建 bucket
mc mb local/$BUCKET_NAME

# 迁移报销附件
mysql -h localhost -P 3306 -u root -p'iWhale@2023' fs_enabling \
  -e "SELECT attach_id, attach_path, attach_name FROM trans_attach" \
  | while read -r line; do
      attach_id=$(echo "$line" | cut -f1)
      attach_path=$(echo "$line" | cut -f2)
      attach_name=$(echo "$line" | cut -f3)
      
      if [ -f "$OLD_ATTACHMENTS_DIR/$attach_path" ]; then
          mc cp "$OLD_ATTACHMENTS_DIR/$attach_path" "local/$BUCKET_NAME/trans/$attach_name"
          echo "已迁移: $attach_name"
      fi
  done

# 迁移借款附件
mysql -h localhost -P 3306 -u root -p'iWhale@2023' fs_enabling \
  -e "SELECT attach_id, attach_path, attach_name FROM loan_attach" \
  | while read -r line; do
      attach_id=$(echo "$line" | cut -f1)
      attach_path=$(echo "$line" | cut -f2)
      attach_name=$(echo "$line" | cut -f3)
      
      if [ -f "$OLD_ATTACHMENTS_DIR/$attach_path" ]; then
          mc cp "$OLD_ATTACHMENTS_DIR/$attach_path" "local/$BUCKET_NAME/loan/$attach_name"
          echo "已迁移: $attach_name"
      fi
  done

echo "附件迁移完成"
```

**交付物**:
- [x] `14-migrate-attachments.sh` - 附件迁移脚本

---

### 12. 数据验证（任务ID: MIG-012）

**目标**: 验证迁移后数据的正确性和完整性

**验证检查项**:

1. **数量验证**:
   ```sql
   -- 对比源数据和目标数据的记录数
   SELECT 'trans', COUNT(*) FROM fs_enabling.trans UNION ALL
   SELECT 'trans', COUNT(*) FROM new_fs.trans WHERE tenant_id = 2;
   
   SELECT 'loan', COUNT(*) FROM fs_enabling.loan UNION ALL
   SELECT 'loan', COUNT(*) FROM new_fs.loan WHERE tenant_id = 2;
   ```

2. **完整性验证**:
   ```sql
   -- 检查外键关系
   SELECT COUNT(*) AS orphan_trans_items 
   FROM new_fs.trans_item ti 
   LEFT JOIN new_fs.trans t ON ti.trans_id = t.trans_id 
   WHERE t.trans_id IS NULL;
   ```

3. **一致性验证**:
   ```sql
   -- 检查金额计算
   SELECT trans_id, trans_charge, SUM(charge_amount) as sum_charge
   FROM new_fs.trans t
   LEFT JOIN new_fs.trans_item ti ON t.trans_id = ti.trans_id
   LEFT JOIN new_fs.charge_item ci ON ti.trans_item_id = ci.trans_item_id
   WHERE t.tenant_id = 2
   GROUP BY trans_id, trans_charge
   HAVING ABS(trans_charge - SUM(charge_amount)) > 0.01;
   ```

4. **权限验证**:
   ```sql
   -- 检查用户权限
   SELECT u.user_id, u.username, r.role_name
   FROM new_fs.user u
   JOIN new_fs.user_role ur ON u.user_id = ur.user_id
   JOIN new_fs.role r ON ur.role_id = r.role_id
   WHERE u.tenant_id = 2;
   ```

**交付物**:
- [x] `15-validate-data.sql` - 数据验证脚本
- [x] `16-validation-report.md` - 验证报告模板

---

## 📊 迁移时间表

| 阶段 | 任务 | 预计工时 | 实际工时 | 负责人 | 状态 |
|------|------|---------|---------|--------|------|
| 数据分析 | MIG-001 | 2天 | - | - | 📋 待开始 |
| 类型映射 | MIG-002 | 1天 | - | - | 📋 待开始 |
| 数据清洗 | MIG-003 | 2天 | - | - | 📋 待开始 |
| 用户迁移 | MIG-004 | 1天 | - | - | 📋 待开始 |
| 组织迁移 | MIG-005 | 0.5天 | - | - | 📋 待开始 |
| 权限迁移 | MIG-006 | 0.5天 | - | - | 📋 待开始 |
| 报销迁移 | MIG-007 | 2天 | - | - | 📋 待开始 |
| 借款迁移 | MIG-008 | 1天 | - | - | 📋 待开始 |
| 还款迁移 | MIG-009 | 1天 | - | - | 📋 待开始 |
| 工作流迁移 | MIG-010 | 3天 | - | - | 📋 待开始 |
| 附件迁移 | MIG-011 | 1天 | - | - | 📋 待开始 |
| 数据验证 | MIG-012 | 1天 | - | - | 📋 待开始 |
| 总计 | - | **16天** | - | - | - |

---

## ⚠️ 风险控制

### 1. 数据丢失风险

**预防措施**:
- 迁移前完整备份源数据库
- 在测试环境充分验证迁移脚本
- 保留源数据库 1 个月后再删除

**应急方案**:
- 如果迁移失败，从备份恢复
- 保留详细的迁移日志

### 2. 数据一致性风险

**预防措施**:
- 使用数据库事务保证一致性
- 迁移后进行完整性检查
- 数据验证失败时不切换系统

**应急方案**:
- 修复迁移脚本后重新迁移
- 手动修复不一致的数据

### 3. 业务中断风险

**预防措施**:
- 选择业务低峰期进行割接
- 准备回滚方案
- 提前通知用户

**应急方案**:
- 立即回滚到旧系统
- 修复问题后重新割接

### 4. 性能风险

**预防措施**:
- 分批迁移大数据量
- 使用批量插入优化性能
- 迁移后进行性能测试

**应急方案**:
- 优化迁移脚本
- 调整数据库配置

---

## 📝 迁移检查清单

### 迁移前检查

- [ ] 源数据库备份完成
- [ ] 迁移脚本测试通过
- [ ] 测试环境数据验证通过
- [ ] 迁移窗口期确认
- [ ] 回滚方案准备就绪
- [ ] 用户通知已发送
- [ ] 运维人员已安排

### 迁移中监控

- [ ] 监控迁移进度
- [ ] 监控迁移错误
- [ ] 实时记录迁移日志
- [ ] 及时处理异常

### 迁移后验证

- [ ] 数据数量验证通过
- [ ] 数据完整性验证通过
- [ ] 数据一致性验证通过
- [ ] 业务功能测试通过
- [ ] 性能测试通过
- [ ] 用户验收通过
- [ ] 运维文档更新完成

---

**文档版本**: v1.0  
**创建日期**: 2026-01-24  
**状态**: 设计阶段，待审阅
